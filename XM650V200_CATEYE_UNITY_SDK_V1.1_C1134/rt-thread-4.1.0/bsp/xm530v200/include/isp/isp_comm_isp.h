#ifndef __ISP_COMM_ISP_H__
#define __ISP_COMM_ISP_H__

#include "isp_type.h"
#include "isp_common.h"
#include "isp_idefines.h"
#include "mpi_ispapp.h"



/****************************************************************************
 * MACRO DEFINITION                                                         *
 ****************************************************************************/
    
#define IB_MAX_COMM_POOLS	(3)
#define VREG_MAX_NUM        16

#define AE_ZONE_ROW     	(7)
#define AE_ZONE_COLUMN  	(7)
#define LUT_FACTOR          (8)
#define GAMMA_FE_LUT_SIZE   ((1<<LUT_FACTOR)+1)

#define GAMMA_NODE_NUMBER   97

#define SHADING_TABLE_NODE_NUMBER_MAX (129)

#define LIGHTSOURCE_NUM      (4)
#define STATIC_DP_COUNT_MAX  (2048)

#define ISP_REG_BASE        0x205A0000
#define ISP_REG_SIZE        0x7fff

#define ISP_WINDOW0_START   0x205A010C
#define ISP_WINDOW0_SIZE    0x205A0110
#define ISP_WINDOW2_START   0x205A0120
#define ISP_WINDOW2_SIZE    0x205A0124

#define ISP_BYPASS_BASE     0x205A0040

#define ISP_MAX_SNS_REGS    16
#define ISP_MAX_DEV_NUM     1


#define ISP_AUTO_STENGTH_NUM	(16)

#define ISP_V2_ZONE_ROW     		(16)
#define ISP_V2_ZONE_COLUMN  	(32)

/****************************************************************************
 * GENERAL STRUCTURES                                                       *
 ****************************************************************************/

typedef enum stISP_ERR_CODE_E
{
    ERR_ISP_NOT_INIT                = 0x40,
    ERR_ISP_TM_NOT_CFG              = 0x41,
    ERR_ISP_ATTR_NOT_CFG            = 0x42,
    ERR_ISP_SNS_UNREGISTER          = 0x43,
    ERR_ISP_INVALID_ADDR            = 0x44,
    ERR_ISP_NOMEM                   = 0x45,
} ISP_ERR_CODE_E;

typedef enum enISP_BAYER_FORMAT_E
{
    BAYER_RGGB    = 0,
    BAYER_GRBG    = 1,
    BAYER_GBRG    = 2,
    BAYER_BGGR    = 3,
    OTHER_RGB_G  = 4,
    OTHER_RGB_IR = 5,
    BAYER_BUTT      
} ISP_BAYER_FORMAT_E;

typedef enum enISP_OP_TYPE_E
{
    OP_TYPE_AUTO    = 0,
    OP_TYPE_MANUAL  = 1,
    OP_TYPE_KEY  = 2,  	
    OP_TYPE_OTHER  = 3, 
    OP_TYPE_BUTT	
} ISP_OP_TYPE_E;

typedef enum enWDR_MODE_E
{
    WDR_MODE_NONE = 0,		// normal(linear)
    WDR_MODE_BUILD_IN,
    WDR_MODE_2To1_LINE,
    WDR_MODE_BUTT,
} WDR_MODE_E;

#define ISP_AE_ROUTE_MAX_NODES 8
typedef struct stISP_AE_ROUTE_NODE_S
{
    ISP_U32  u32IntTime;
    ISP_U32  u32SysGain;     /* shift is in the ISP_AE_ATTR_S's stSysGainRange. */
    ISP_U32  u32ApePercent;  /* the percent of the iris's aperture, range is [0~100], dc-iris not support in auto mode. */
} ISP_AE_ROUTE_NODE_S;

typedef struct stISP_AE_ROUTE_S
{
    ISP_U32 u32TotalNum;    
    ISP_AE_ROUTE_NODE_S astRouteNode[ISP_AE_ROUTE_MAX_NODES];
} ISP_AE_ROUTE_S;

typedef enum stISP_AE_MODE_E
{
    AE_MODE_LOW_NOISE   = 0,
    AE_MODE_FRAME_RATE  = 1,
    AE_MODE_BUTT
} ISP_AE_MODE_E;


typedef enum stISP_AE_WEIGHT_E
{
	AE_WEIGHT_V1 = 0,	// 7*7
    AE_WEIGHT_V2 = 1,	// 32*16
    AE_WEIGHT_BUTT
} ISP_AE_WEIGHT_E;


typedef enum stISP_FS_MODE_E
{
    OUTMODE_LONG_FRAME    = 0,
    OUTMODE_SHORT_FRAME  = 1,
    OUTMODE_FUSION_FRAME  = 2,
    OUTMODE_DEBUG_OSD  = 3, 
    OUTMODE_DEBUG_MD  = 4, 
    OUTMODE_DEBUG_ZONE  = 5, 
    OUTMODE_BUTT	
} ISP_FS_MODE_E;


typedef struct stISP_WDR_EXPOSURE_ATTR_S
{
    ISP_OP_TYPE_E enExpRatioType;   /* RW, OP_TYPE_AUTO: The ExpRatio used in ISP is generated by firmware; OP_TYPE_MANUAL: The ExpRatio used in ISP is set by u32ExpRatio */
    ISP_U32 u32ExpRatio;             /* RW, Range: [0x40, 0xFFF]. Format: unsigned 6.6-bit fixed-point. 0x40 means 1 times.
                                            When enExpRatioType is OP_TYPE_AUTO, u32ExpRatio is invalid.
                                            When enExpRatioType is OP_TYPE_MANUAL, u32ExpRatio is quotient of long exposure time / short exposure time. */
    ISP_U32 u32ExpRatioMax;          /* RW, Range: [0x40, 0xFFF]. Format: unsigned 6.6-bit fixed-point. 0x40 means 1 times.
                                            When enExpRatioType is OP_TYPE_AUTO, u32ExpRatioMax is max(upper limit) of ExpRatio generated by firmware.
                                            When enExpRatioType is OP_TYPE_MANUAL, u32ExpRatioMax is invalid. */
    ISP_U32 u32ExpRatioMin;          /* RW, Range: [0x40, u32ExpRatioMax]. 6bit precision, 0x40 means 1 times.
                                            When enExpRatioType is OP_TYPE_AUTO, u32ExpRatioMin is min(lower limit) of ExpRatio generated by firmware.
                                            When enExpRatioType is OP_TYPE_MANUAL, u32ExpRatioMin is invalid. */
    ISP_U16 u16Tolerance;            /* RW, Range: [0x0, 0xFF], set the dynamic range tolerance. Format: unsigned 6.2-bit fixed-point. 0x4 means 1dB. */
    ISP_U16 u16Speed;                /* RW, Range: [0x0, 0xFF], exposure ratio adjust speed */   
    ISP_U16 u16RatioBias;            /* RW, Range: [0x0, 0xFFFF], exposure ratio bias */
} ISP_WDR_EXPOSURE_ATTR_S;

typedef enum stISP_AWB_ALG_TYPE_E
{
	AWB_ALG_DEFAULT = 0,
	AWB_ALG_ADVANCE = 1,
	AWB_ALG_BUTT
    
} ISP_AWB_ALG_TYPE_E;

typedef enum stISP_WB_MODE_E
{
    /* all auto*/
    WB_AUTO = 0,
    
    /* half auto */        
    WB_FLUORESCENT,        /*fluorescent*/
    WB_LAMP,                /*lamp*/
    WB_DAYLIGHT,            /*daylight*/
    WB_FLASH,                /*flash light*/
    WB_CLOUDY,                /*cloudy*/
    WB_SHADOW,                /*shadow*/
    WB_BUTT
} ISP_WB_MODE_E;

typedef struct stISP_WINDOW_S
{
    ISP_U16 u16Start;
    ISP_U16 u16Length;
} ISP_WINDOW_S;

typedef enum stISP_WIND_MODE_E
{
    ISP_WIND_NONE        = 0,
    ISP_WIND_HOR        = 1,
    ISP_WIND_VER        = 2,
    ISP_WIND_ALL        = 3,
    ISP_WIND_BUTT
} ISP_WIND_MODE_E;

typedef enum stISP_IRIS_STATUS_E
{
    ISP_IRIS_KEEP  = 0,       /* Do nothing to Iris */
    ISP_IRIS_OPEN  = 1,       /* Open Iris to the max */
    ISP_IRIS_CLOSE = 2,       /* Close Iris to the min */
    ISP_IRIS_BUTT
} ISP_IRIS_STATUS_E;

typedef enum stISP_TRIGGER_STATUS_E
{
    ISP_TRIGGER_INIT     = 0,  /* Initial status, before trigger */
    ISP_TRIGGER_SUCCESS  = 1,  /* Trigger finished successfully */
    ISP_TRIGGER_TIMEOUT  = 2,  /* Trigger finished because of time out */
    ISP_TRIGGER_BUTT
} ISP_TRIGGER_STATUS_E;

typedef enum stISP_WDR_MODE_E
{
    ISP_SENSOR_LINEAR_MODE = 0,
    ISP_SENSOR_WDR_MODE,

    ISP_WDR_BUTT,
} ISP_WDR_MODE_E;

typedef struct stISP_WDR_ATTR_S
{
    ISP_WDR_MODE_E  enWdrMode;
} ISP_WDR_ATTR_S;

typedef struct stISP_INPUT_TIMING_S
{
    ISP_WIND_MODE_E enWndMode;
    ISP_U16 u16HorWndStart;    /*RW, Range: [0x0, 0x780]*/
    ISP_U16 u16HorWndLength;   /*RW, Range: [0x0, 0x780]*/
    ISP_U16 u16VerWndStart;    /*RW, Range: [0x0, 0x4B0]*/
    ISP_U16 u16VerWndLength;   /*RW, Range: [0x0, 0x4B0]*/
} ISP_INPUT_TIMING_S;

typedef struct stISP_VF_ATTR_S
{
	ISP_OP_TYPE_E opType;
	ISP_SIZE_S stAutoAttr;
}ISP_VF_ATTR_S;

typedef struct stISP_3DNR_CONFIG_S
{
	ISP_U32 u32PhyAddr;// 3D Buffer 
	ISP_U32 u32ErrPhyAddr;	
	ISP_U32 u32Size;	//
	ISP_U32 u32ErrSize;	// bit0~bit15: SizeH  bit16~bit31:SizeV
	ISP_U32 u32ChangePoint;
	ISP_U8  u8BufFNum;
	ISP_U32 au32Rsv[4];
}ISP_3DNR_CONFIG_S;

typedef struct stISP_PUB_ATTR_S
{
	ISP_U8  u8FrameRate;			// RW
	ISP_U8  au8Rsv[7];
	ISP_RECT_S 	stWndRect;				// RW
	ISP_SIZE_S  stSizeVpss;				// the size of vpss in(for isp)
	ISP_BAYER_FORMAT_E	enBayer;		// RW
	WDR_MODE_E enWdrMode;
	//down
	ISP_BOOL bEnDown;
	ISP_U32 u32DownDelta;	//[0x400,0x1000]
	ISP_SIZE_S stSizeDown;
	
	ISP_U32 au32Rsv[4];
}ISP_PUB_ATTR_S;


typedef struct stISP_IMAGE_ATTR_S
{
    ISP_U16 u16Width;        /*RW, Range: [0x0, 0x780]*/
    ISP_U16 u16Height;       /*RW, Range: [0x0, 0x4B0]*/
    ISP_U16 u16FrameRate;    /*RW, Range: [0x0, 0xFF]*/        
    ISP_BAYER_FORMAT_E  enBayer;    
} ISP_IMAGE_ATTR_S;

typedef enum stISP_MOD_BYPASS_E
{
    ISP_MOD_SHARPEN     = 0x8000,
    ISP_MOD_GAMMARGB    = 0x4000,
    ISP_MOD_COLORMATRIX = 0x2000,
    ISP_MOD_DEMOSAIC    = 0x1000,
    
    ISP_MOD_GAMMAPOST   = 0x0800,
    ISP_MOD_GAMMAPRE    = 0x0200,
    ISP_MOD_SHADING     = 0x0100,

    ISP_MOD_DRC         = 0x0080,
    ISP_MOD_GAIN        = 0x0040,
    ISP_MOD_SINTER      = 0x0008,
    ISP_MOD_HOTPIXEL    = 0x0004,
    ISP_MOD_GAMMAFE     = 0x0002,
    ISP_MOD_BALANCEFE   = 0x0001,
    ISP_MOD_BUTT
    
} ISP_MOD_BYPASS_E;


typedef enum stISP_AE_FRAME_END_UPDATE_E
{
    ISP_AE_FRAME_END_UPDATE_0  = 0x0, //isp update gain and exposure  in the  same frame
    ISP_AE_FRAME_END_UPDATE_1  = 0x1, //isp update exposure one frame before  gain
    ISP_AE_FRAME_END_UPDATE_2  = 0x2, //isp update exposure one frame before  gain, isr config
    ISP_AE_FRAME_END_BUTT,
}ISP_AE_FRAME_END_UPDATE_E;

/* 4A settings                                                              */


typedef enum stISP_AE_STRATEGY_E
{
	AE_EXP_NORMAL = 0,
	AE_EXP_HIGHLIGHT_PRIOR = 1,
	AE_EXP_LOWLIGHT_PRIOR  = 2,
	AE_EXP_CENTERLIGHT_PRIOR = 3,
	AE_STRATEGY_MODE_BUTT
} ISP_AE_STRATEGY_E;


typedef struct stISP_AE_RANGE_S
{
    ISP_U32 u32Max;
    ISP_U32 u32Min;
} ISP_AE_RANGE_S;

typedef enum stISP_ANTIFLICKER_MODE_E
{
    /* The exposure time is fixed at several values. The minimum exposure time is 1/120 sec.
     * (60 Hz) or 1/100 sec. (50 Hz). Since the exposure time is synchronized with the fluorescent lighting,
     * rolling bar noise can be suppressed. In high-luminance environments, however, 
     * the exposure time is fixed to the minimum exposure time, it may lead to over exposure
     */
    ISP_ANTIFLICKER_MODE_0 = 0x0,

    /* In this mode, the exposure time is not fixed in high-luminance environments and the 
     * exposure time can be reduced  to the minimum . Use it when the exposure is to be controlled
     * in high-luminance environments. in low lumiance enviroment, the effect is the same as the above one
     */
    ISP_ANTIFLICKER_MODE_1 = 0x1,

    ISP_ANTIFLICKER_MODE_BUTT      
}ISP_ANTIFLICKER_MODE_E;

typedef struct stISP_ANTIFLICKER_S
{
    ISP_BOOL bEnable;
    ISP_U8   u8Frequency;          /*RW, Range: usually this value is 50 or 60  which is the frequency of the AC power supply*/

    ISP_ANTIFLICKER_MODE_E  enMode;
} ISP_ANTIFLICKER_S;

typedef struct stISP_AE_DELAY_S
{
    ISP_U16 u16BlackDelayFrame;     // Need ToBrighter	delay = u16BlackDelayFrame x2 (FrameNums) 
    ISP_U16 u16WhiteDelayFrame;    // Need ToDarker		delay = u16WhiteDelayFrame x2 (FrameNums) 
} ISP_AE_DELAY_S;

typedef struct stISP_AE_ATTR_S
{
	/* base parameter */
	ISP_AE_RANGE_S stExpTimeRange;   /*RW,  sensor exposure time (unit: us ), Range: [0x0, 0xFFFFFFFF], it's related to the specific sensor */
	ISP_AE_RANGE_S stAGainRange;     /*RW,  sensor analog gain (unit: times, 10bit precision), Range : [0x400, 0xFFFFFFFF], it's related to the specific sensor */
	ISP_AE_RANGE_S stDGainRange;     /*RW,  sensor digital gain (unit: times, 10bit precision), Range : [0x400, 0xFFFFFFFF], it's related to the specific sensor */
	ISP_AE_RANGE_S stISPDGainRange;  /*RW,  ISP digital gain (unit: times, 10bit precision), Range : [0x400, 0xFFFFFFFF], it's related to the ISP digital gain range */
	ISP_AE_RANGE_S stSysGainRange;   /*RW,  system gain (unit: times, 10bit precision), Range : [0x400, 0xFFFFFFFF], it's related to the specific sensor and ISP Dgain range */
	ISP_U32 u32BindSyncRatio;
	ISP_U32 u32LinesPer500ms;
	ISP_S32 s32IspGainEx;
/********************************
u32UpdateCfg:
	bit[0~7]  period
	bit[8~15] shut 
	bit[16~23] snsGain
	bit[24~31] ispGain
********************************/
	ISP_U32  u32UpdateCfg;	
	ISP_U8  u8Speed;                  /*RW, Range: [0x0, 0xFF], AE adjust step*/
	ISP_U8  u8Tolerance;              /*RW, Range: [0x0, 0xFF], AE adjust tolerance*/
	ISP_U8  u8Compensation;           /*RW, Range: [0x0, 0xFF], AE compensation*/ 
	ISP_U8  u8BindSyncChn;			/*RW: 0xFF not bind */
/********************************
u16AlgMode:
	0x00: fix V1 
	0x10: fix V2
********************************/
	ISP_U16  u16AlgMode;
	ISP_AE_STRATEGY_E enAEStrategyMode;  /*RW, Support Highlight prior or Lowlight prior*/
	ISP_U16 u16AEStrategyStr;       /*RW, Range: [0x0, 0xFFFF], AE hist ratio slope*/

	ISP_AE_MODE_E  enAEMode;         /*RW, AE mode(slow shutter/fix framerate)(onvif)*/
	ISP_ANTIFLICKER_S stAntiflicker;
	ISP_AE_DELAY_S stAEDelayAttr;

	/*AE weighting table*/
	ISP_AE_WEIGHT_E enAeWeightMode;
	union
	{
		ISP_U8 au8Weight_v1[AE_ZONE_ROW][AE_ZONE_COLUMN]; 			/*Range :  [0, 0xF]*/
		ISP_U8 au8Weight_v2[ISP_V2_ZONE_ROW][ISP_V2_ZONE_COLUMN]; 	/*Range :  [0, 0xF]*/
	};
} ISP_AE_ATTR_S;


typedef struct stISP_EXP_STA_INFO_S
{
	ISP_U16 u16Exp_Hist16Value[16];	/*RO, 16 bins histogram,Range: [0x0, 0xFFFF]*/
	ISP_U8  u8AveLum;                      	/*RO, average lum,Range: [0x0, 0xFF]*/
	ISP_U8  u8ExpHistTarget[16];  		/*RW, Histogram target for bin 0/1/2/3/4 */
	ISP_S16 s16HistError;   

	ISP_U8 u8HisTarget;
}ISP_EXP_STA_INFO_S;

typedef struct stISP_ME_ATTR_S
{
    ISP_S32 s32AGain;            /*RW,  sensor analog gain (unit: times), Range: [0x0, 0xFF],it's related to the specific sensor */
    ISP_S32 s32DGain;            /*RW,  sensor digital gain (unit: times), Range: [0x0, 0xFF],it's related to the specific sensor */
    ISP_U32 u32ExpLine;          /*RW,  sensor exposure time (unit: line ), Range: [0x0, 0xFFFF],it's related to the specific sensor */
    ISP_S32 s32IspGain;
    ISP_S32 u32Exp; 
	
    ISP_BOOL bManualExpLineEnable;
    ISP_BOOL bManualAGainEnable;
    ISP_BOOL bManualDGainEnable;
    ISP_BOOL bManualIspGainEnable;
    ISP_BOOL bManualExpEnable;
} ISP_ME_ATTR_S;

typedef struct stISP_ME_ATTR_EX_S
{
    ISP_S32 s32AGain;            /*RW,  sensor analog gain (unit: times), Range: [0x0, 0xFF],it's related to the specific sensor */
    ISP_S32 s32DGain;            /*RW,  sensor digital gain (unit: times), Range: [0x0, 0xFF],it's related to the specific sensor */
    ISP_U32 u32ISPDGain;         /*RW,  sensor digital gain (unit: times), Range: [0x0, 0xFF],it's related to the specific isp   */
    ISP_U32 u32ExpLine;          /*RW,  sensor exposure time (unit: line ), Range: [0x0, 0xFFFF],it's related to the specific sensor */

    ISP_BOOL bManualExpLineEnable;
    ISP_BOOL bManualAGainEnable;
    ISP_BOOL bManualDGainEnable;
    ISP_BOOL bManualISPGainEnable;
} ISP_ME_ATTR_EX_S;

typedef struct stISP_AF_ATTR_S
{
    ISP_S32 s32FocusDistanceMax; /* the focuse range */
    ISP_S32 s32FocusDistanceMin;

    /* weighting table */
    ISP_U8 u8Weight[AE_ZONE_ROW][AE_ZONE_COLUMN];    
} ISP_AF_ATTR_S;

typedef struct stISP_FOUCS_STA_INFO_S
{
    ISP_U16 u16FocusMetrics;     /*RO, The integrated and normalized measure of contrast*/
    ISP_U16 u16ThresholdRead;    /*RO, The ISP recommend value of AF threshold*/
    ISP_U16 u16ThresholdWrite;   /*RW, The user defined value of AF threshold (or 0 to use threshold from previous frame)*/
    ISP_U16 u16FocusIntensity;   /*RO, The average brightness*/
    ISP_U8  u8MetricsShift;      /*RW, Metrics scaling factor:the bigger value for this register means all zones metrics go higher,0x03 is the default, Range: [0x0, 0xF]*/
    ISP_U8  u8NpOffset;          /*RW, The AF noise profile offset, Range: [0x0, 0xFF]*/
	ISP_U16 u16ZoneMetrics[AE_ZONE_ROW][AE_ZONE_COLUMN]; /*RO, The zoned measure of contrast*/    
} ISP_FOCUS_STA_INFO_S;

typedef struct stISP_MF_ATTR_S
{
    ISP_S32 s32DefaultSpeed;     /* 1,default speed(unit:m/s).(onvif)*/    
} ISP_MF_ATTR_S;

typedef struct stISP_AWBCCM_RSV_S 
{ 
	ISP_U32 u32Rsv;
	ISP_U16 au16Rsv[3];
	ISP_U8 au8Rsv[4];   
} ISP_AWBCCM_RSV_S; 

typedef struct stISP_AWB_ATTR_S
{
	ISP_U16 u16SpeedToH;			/*RW, Range: [0x0, 0xFFF]  Ratio:[0x0, 0xFFFF]*/
	ISP_U16 u16SpeedToL;			/*RW, Range: [0x0, 0xFFF]  Coef:[0x0, 0x400]*/
	ISP_U16 au16Rsv[6];
	ISP_U8 u8RbOfst;        			/*RW, Range: [0x0, 0xFF]*/
	ISP_U8 u8ROfst;				/*RW, Range: [0x0, 0xFF]*/
	ISP_U8 u8BOfst;				/*RW, Range: [0x0, 0xFF]*/
	ISP_U8 u8GmOfst;        			/*RW, Range: [0x0, 0xFF]*/
	ISP_U8 u8ZoneSel;           		/*RW,  A value of 0 or 0x3F means global AWB, A value between 0 and 0x3F means zoned AWB */
	ISP_U8 u8HighColorTemp;     /*RW, AWB max temperature in K/100, Range: [0x0, 0xFF], Recommended: [u8LowColorTemp, 100] */
	ISP_U8 u8LowColorTemp;      /*RW, AWB min temperature in K/100, Range: [0x0, u8HighColorTemp), Recommended: [20, u8HighColorTemp] */
	ISP_U8 u8BindSyncChn;
	ISP_U8 au8Rsv[4];
	/* weighting table */
	ISP_U8 u8Weight[AE_ZONE_ROW][AE_ZONE_COLUMN];  /*RW, Range :  [0, 0xF]*/
} ISP_AWB_ATTR_S;

typedef struct stISP_AWB_IN_OUT_ATTR_S
{
    ISP_BOOL bEnable;
    ISP_OP_TYPE_E   enOpType;
    ISP_BOOL bOutdoorStatus;                /*in Auto mode, this is RO, in Manual mode, this is WO*/
    ISP_U32 u32OutThresh;                   /*shutter time(in us) to judge indoor or outdoor */
    ISP_U16 u16LowStart;                    /*5000K is recommend. [u8LowStart, u8HighStart] is the color temperature range of Day Light*/
    ISP_U16 u16LowStop;                     /*4500K is recommend, u16LowStop < u8LowStart*/
    ISP_U16 u16HighStart;                   /*6500K is recommend, u16HighStart > u8LowStart*/
    ISP_U16 u16HighStop;                    /*8000K is recommend, u16HighStop > u8HighStart*/
    ISP_BOOL bGreenEnhanceEn;               /*If this is enabled, Green channel will be enhanced based on the area of green plant, only take effect outdoor*/
} ISP_AWB_IN_OUT_ATTR_S;

typedef struct stISP_AWB_CT_LIMIT_ATTR_S
{
    ISP_BOOL bEnable;
    ISP_OP_TYPE_E   enOpType;

    ISP_U16 u16HighRgLimit;     /*RO, in Manual Mode, user should define the Max Rgain of High Color Temperature, u16HighRgLimit > u16LowRgLimit*/
    ISP_U16 u16HighBgLimit;     /*RO, in Manual Mode, user should define the Min Bgain of High Color Temperature, u16HighBgLimit < u16LowBgLimit*/
    ISP_U16 u16LowRgLimit;      /*RO, in Manual Mode, user should define the Min Rgain of Low Color Temperature*/
    ISP_U16 u16LowBgLimit;      /*RO, in Manual Mode, user should define the Max Bgain of Low Color Temperature*/
} ISP_AWB_CT_LIMIT_ATTR_S;

typedef struct stISP_ADV_AWB_ATTR_S
{
    ISP_BOOL bAccuPrior;         /*RW, recommend 0 for outdoor, 1 for indoor*/    
    ISP_U8  u8Tolerance;         /*RW, Range:[0x0, 0xFF], AWB adjust tolerance,for outdoor, this value should be small,recomend 4*/   
    ISP_U16 u16CurveLLimit;      /*RW, Range:[0x0, 0x100],   Left limit of AWB Curve, recomend for indoor 0xE0, outdoor 0xE0*/ 
    ISP_U16 u16CurveRLimit;      /*RW, Range:[0x100, 0xFFF], Right Limit of AWB Curve,recomend for indoor 0x130, outdoor 0x120*/ 

    ISP_BOOL bGainNormEn;     
    ISP_AWB_IN_OUT_ATTR_S       stInOrOut;    
    ISP_AWB_CT_LIMIT_ATTR_S     stCTLimit;
} ISP_ADV_AWB_ATTR_S;

typedef struct stISP_AWB_LIGHTSOURCE_INFO_S
{
    ISP_U16 u16WhiteRgain;        /*G/R of White points at this light source*/
    ISP_U16 u16WhiteBgain;        /*G/B of White points at this light source*/
    ISP_U16 u16ExpQuant;          /*shtter time * again * dgain >> 4, Not support Now*/
    ISP_BOOL bLightStatus;         /*RW, 0: idle  1:busy */	
} ISP_AWB_LIGHTSOURCE_INFO_S;

typedef struct stISP_AWB_ADD_LIGHTSOURCE_S
{
    ISP_BOOL  bLightEnable;                     /*Enable special light source function*/
    ISP_AWB_LIGHTSOURCE_INFO_S	stLightInfo[LIGHTSOURCE_NUM]; 
} ISP_AWB_ADD_LIGHTSOURCE_S;

typedef struct stISP_WB_ZONE_STA_INFO_S
{
    ISP_U16 u16Rg;               /*RO, Zoned WB output G/R, Range : [0x0, 0xFFF]*/
    ISP_U16 u16Bg;               /*RO, Zoned WB output G/B, Range : [0x0, 0xFFF]*/
    ISP_U32 u32Sum;              /*RO, Zoned WB output population,Range: [0x0, 0xFFFFFFFF]*/  
} ISP_WB_ZONE_STA_INFO_S;

typedef struct stISP_WB_STA_INFO_S
{
    ISP_U16 u16WhiteLevel;       /*RW, Upper limit of valid data for white region, Range: [0x0, 0xFFFF]*/
    ISP_U16 u16BlackLevel;       /*RW, Lower limit of valid data for white region, Range: [0x0, u16WhiteLevel)*/
    ISP_U16 u16CbMax;            /*RW, Maximum value of B/G for white region, Range: [0x0,0xFFF]*/
    ISP_U16 u16CbMin;            /*RW, Minimum value of B/G for white region, Range: [0x0, u16CbMax)*/
    ISP_U16 u16CrMax;            /*RW, Maximum value of R/G for white region, Range: [0x0, 0xFFF]*/
    ISP_U16 u16CrMin;            /*RW, Minimum value of R/G for white region, Range: [0x0, u16CrMax)*/
    
    ISP_U16 u16GRgain;           /*RO, Global WB output G/R, Range: [0x0, 0xFFFF]*/
    ISP_U16 u16GBgain;           /*RO, Global WB output G/B, Range: [0x0, 0xFFFF]*/
    ISP_U32 u32GSum;             /*RO, Global WB output population, Range: [0x0, 0xFFFF]*/

    ISP_U32 u32Rgain;            /*RO, gain value of R channel for AWB, Range: [0x0, 0xFFF]*/
    ISP_U32 u32Ggain;            /*RO, gain value of G channel for AWB, Range: [0x0, 0xFFF]*/
    ISP_U32 u32Bgain;            /*RO, gain value of B channel for AWB, Range: [0x0, 0xFFF]*/
    
    ISP_WB_ZONE_STA_INFO_S stZoneSta[AE_ZONE_ROW][AE_ZONE_COLUMN];  /*RO, Zoned WB statistics*/
} ISP_WB_STA_INFO_S;

typedef struct stISP_MWB_ATTR_S        
{
    ISP_U16 u16Rgain;            /*RW, Multiplier for R color channel, Range: [0x0, 0xFFF]*/
    ISP_U16 u16Ggain;            /*RW, Multiplier for G color channel, Range: [0x0, 0xFFF]*/
    ISP_U16 u16Bgain;            /*RW, Multiplier for B color channel, Range: [0x0, 0xFFF]*/
    
} ISP_MWB_ATTR_S;



// CCM
typedef struct stISP_COLORMATRIX_AUTO_S
{   ISP_U16 u16HighColorTemp;    /*RW,  Range: [u16MidColorTemp + 400,  10000]*/
    ISP_S16 as16HighCCM[12];      /*RW,  Range: [0x0,  0xFFFF]*/
    ISP_U16 u16MidColorTemp;     /*RW,  the MidColorTemp should be at least 400 smaller than HighColorTemp, Range: [u16LowColorTemp + 400,  u16HighColorTemp-400]*/
    ISP_S16 as16MidCCM[12];       /*RW,  Range: [0x0,  0xFFFF]*/
    ISP_U16 u16LowColorTemp;     /*RW,  the LowColorTemp should be at least 400 smaller than HighColorTemp, Range: [0,  u16MidColorTemp-400]*/
    ISP_S16 as16LowCCM[12];       /*RW,  Range: [0x0,  0xFFFF]*/
} ISP_COLORMATRIX_AUTO_S;


typedef struct stISP_COLORMATRIX_MANUAL_S
{   
	ISP_S16 as16CCM[12];      /*RW,  Range: [0x0,  0xFFFF]*/
} ISP_COLORMATRIX_MANUAL_S;

typedef struct stISP_COLORMATRIX_ATTR_S
{   
	ISP_BOOL bByPass;
	ISP_OP_TYPE_E enOpType;
	ISP_COLORMATRIX_MANUAL_S stManual;
	ISP_COLORMATRIX_AUTO_S stAuto;
} ISP_COLORMATRIX_ATTR_S;





typedef struct stISP_COLORTONE_S
{
  ISP_U16 u16RedCastGain;        /*RW,  Range: [0x100, 0xFFFF], adjust the final red channel  tone of the picture */
  ISP_U16 u16GreenCastGain;      /*RW,  Range: [0x100, 0xFFFF], adjust the final green channel  tone of the picture*/
  ISP_U16 u16BlueCastGain;       /*RW,  Range: [0x100, 0xFFFF], adjust the final blue channel  tone of the picture*/ 
  
}ISP_COLORTONE_S;

typedef enum stISP_SAT_MODE_E
{
    SAT_MODE_NOISE    = 0,	// Lower Noise
    SAT_MODE_COLOR  = 1,		// Better Color
    SAT_MODE_BUTT
} ISP_SAT_MODE_E;


typedef struct stISP_SATURATION_AUTO_S
{
    ISP_U8   au8Sat[ISP_AUTO_STENGTH_NUM];           /*RW,  Range: [0, 0xFF] */ 
}ISP_SATURATION_AUTO_S;

typedef struct stISP_SATURATION_MANUAL_S
{
	ISP_U8	u8Saturation;
}ISP_SATURATION_MANUAL_S;

typedef struct stISP_SATURATION_ATTR_S
{
	ISP_SAT_MODE_E enSatMode;
	ISP_OP_TYPE_E enOpType;
	ISP_SATURATION_MANUAL_S	stManual;
	ISP_SATURATION_AUTO_S stAuto;
}ISP_SATURATION_ATTR_S;



typedef enum stISP_IRIS_TYPE_E
{
    ISP_IRIS_DC_TYPE = 0,
    ISP_IRIS_P_TYPE,
    
    ISP_IRIS_TYPE_BUTT,
} ISP_IRIS_TYPE_E;



typedef struct stISP_MI_ATTR_S
{
    ISP_BOOL bEnable;            /* manual iris  on/off*/
    ISP_U32  u32IrisHoldValue;   /*RW, iris hold value, Range: [0x0, 0x3E8]*/
    ISP_U16  u16ApePercent;      /* the percent of the iris's aperture, range is [0~100]. */
} ISP_MI_ATTR_S;


typedef struct stISP_DRC_MANUAL_ATTR_S 
{
	ISP_U8 u8Strength;
}ISP_DRC_MANUAL_ATTR_S;

typedef struct stISP_DRC_AUTO_ATTR_S 
{
	ISP_U8 au8Sth[ISP_AUTO_STENGTH_NUM];           /*RW,  Range: [0, 0xFF] */ 
}ISP_DRC_AUTO_ATTR_S; 

#define DRC_IDX_NUM		(128)

typedef struct stISP_DRC_ATTR_S
{
	ISP_BOOL bEnable;        
	ISP_OP_TYPE_E enOpType; 
	ISP_U8 u8GlobalSth;	//[0,100] def:50
	ISP_U8 u8Choice;	// 0:DRC	2:DRC(ExtLut)
	ISP_DRC_MANUAL_ATTR_S stManual; 
	ISP_DRC_AUTO_ATTR_S stAuto;
	ISP_U32 au32ToneMappingValue[DRC_IDX_NUM]; /*RW*/
} ISP_DRC_ATTR_S;

typedef struct stISP_HDR_BUILDIN_ATTR_S
{
	ISP_BOOL bEnable;
	ISP_U32 u32IdxNum;	//[4,8]
	ISP_U32 au32X[8];
	ISP_U32 au32Y[8];
	ISP_U32 au32K[8];
}ISP_HDR_BUILDIN_ATTR_S;

typedef struct stISP_HDR_FS_ATTR_S
{
	ISP_BOOL bEnable;
	ISP_OP_TYPE_E enExpRatioType;
	ISP_U32 u32ManualExpRatio;	// [0x40,0xFFFF]
	ISP_FS_MODE_E enOutMode;
	ISP_U16 au16WtThr_Long[3];
	ISP_U16 au16WtK_Long[3];
	ISP_U16 u16MotionThr_Long;
	ISP_U16 u16MotionK_Long;
	ISP_U16 u16MAddrThr_Long;
	ISP_U16 u16MAddrK_Long;
	ISP_U8 u8SharpStr_Long;
	ISP_U8 u8SharpStr_Short;
	ISP_U8 u8DePcolorStr_Long;
	ISP_U8 u8DePcolorStr_Short;
	ISP_U32 au32Rsv[4];
}ISP_HDR_FS_ATTR_S;

typedef struct stISP_HDRDEC_ATTR_S
{
	WDR_MODE_E  enWDRMode;
    union
    {
        ISP_HDR_BUILDIN_ATTR_S stBuildInAttr;
        ISP_HDR_FS_ATTR_S stFusionAttr;
    };
}ISP_HDR_ATTR_S;

typedef struct stISP_WDR_MODE_S
{
    WDR_MODE_E  enWDRMode;
} ISP_WDR_MODE_S;

typedef struct stISP_LIMIT_UP_ATTR_S
{
	ISP_U8 u8Enable;	// bit0:hor  bit4:ver
	LIMITEDUP_TYPE enMode;
	ISP_U16 u16ClkRatio_in;
	ISP_U16 u16ActiveH_in;
	ISP_U16 u16ActiveV_in;
	ISP_U16 u16TotalH_in;
	ISP_U16 u16TotalV_in;

	ISP_U16 u16ClkRatio_out;
	ISP_U16 u16ActiveH_out;
	ISP_U16 u16ActiveV_out;
	ISP_U16 u16TotalH_out;
	ISP_U16 u16TotalV_out;	

	ISP_U16 rsv[4];
}ISP_LIMIT_UP_ATTR_S;


typedef enum enISP_STATIC_DP_TYPE_E{
    ISP_STATIC_DP_BRIGHT = 0x0,  
    ISP_STATIC_DP_DARK,    
    ISP_STATIC_DP_BUTT
} ISP_STATIC_DP_TYPE_E;

typedef struct stISP_DYDPC_AUTO_S
{
	ISP_U8 au8Sth[ISP_AUTO_STENGTH_NUM];           /*RW,  Range: [0, 0xFF] */ 
}ISP_DYDPC_AUTO_S;

typedef struct stISP_DYDPC_MANUAL_S
{
	ISP_U8 u8Sth;
}ISP_DYDPC_MANUAL_S;

typedef struct stISP_DYDPC_ATTR_S
{
	ISP_OP_TYPE_E enOpType;
	ISP_DYDPC_MANUAL_S	stManual;
	ISP_DYDPC_AUTO_S stAuto;
}ISP_DYDPC_ATTR_S;

typedef struct stISP_STDPC_ATTR_S
{
	// StaticDpc
	ISP_BOOL bEnableStatic;
	ISP_BOOL bEnableDetect;
	ISP_STATIC_DP_TYPE_E enStaticDPType;    /* Select static bright/dark defect-pixel calibration. */
    
	ISP_TRIGGER_STATUS_E enTriggerStatus;   /*R   status of bad pixel trigger*/
	ISP_U16 	u16BadPixelThreshMin;          	/*RW,  Range: [0, 0xFFF] */
	ISP_U16 	u16BadPixelThreshMax;        	/*RW,  Range: [0, 0xFFF] */
	ISP_U16  u16BadPixelThresh;				/*R   Range: [0, 0xFFF] */
	ISP_U16  u16BadPixelCountMax;            /*RW, limit of max number of bad pixel,  Range: [0, 0x3FF] */
	ISP_U16  u16BadPixelCount;               /*R	 DP count:[0, 0x3FF]*/
	ISP_U16  u16BadPixelTriggerTime;         /*RW, time limit for bad pixel trigger, in frame number ,Range: [0x0, 0x640]*/
	ISP_U32  u32BadPixelTable[STATIC_DP_COUNT_MAX];         /*RW, Range: [0x0, 0x3FFFFF],the first 11 bits represents the X coordinate of the defect pixel, the second 11 bits represent the Y coordinate of the defect pixel*/
} ISP_STDPC_ATTR_S;

typedef struct stISP_SRAMDPC_ATTR_S
{
	ISP_U16	u16SbpcHighThr;
	ISP_U16	u16SbpcLowThr;
	ISP_U16	u16SbpcPixelCount;
	ISP_U32* u16SbpcPdataaddr;
} ISP_SRAMDPC_ATTR_S;

typedef struct stISP_FPN_DATA_S
{
	ISP_U32 u32DataCnt;
	ISP_U32 *pau32DataPhyAddr;
} ISP_FPN_DATA_S;
typedef struct stISP_FPN_SAINFO_S
{
	ISP_U32  fpn_enable;
	ISP_U32	fpn_sensor_id;
	ISP_RECT_S  fpn_stWndRect;
}ISP_FPN_SAINFO_S;

typedef struct stISP_FPN_AUTO_S
{
	ISP_U8 au8Str[ISP_AUTO_STENGTH_NUM];           /*RW,  Range: [0, 0xFF] */ 
}ISP_FPN_AUTO_S;

typedef struct stISP_FPN_MANUAL_S
{
	ISP_U8 u8Str;
}ISP_FPN_MANUAL_S;

typedef enum stISP_FPN_OBJ_E{
	FPN_TO_ATTR = 0,
	FPN_TO_DATA = 1,
	FPN_OP_BUTT
} ISP_FPN_OBJ_E;

typedef struct stISP_FPN_ATTR_S
{
	ISP_BOOL bEnable;
	ISP_BOOL bEnableDetect;
	ISP_FPN_OBJ_E enObj;
	ISP_SIZE_S stSize;
	ISP_FPN_DATA_S stCalibrationData;
	ISP_TRIGGER_STATUS_E enTriggerStatus;   /*R   status of trigger*/
	// fot strength
	ISP_OP_TYPE_E enOpType;
	ISP_FPN_MANUAL_S stManual;
	ISP_FPN_AUTO_S stAuto;
}ISP_FPN_ATTR_S;


typedef struct stISP_DIS_ATTR_S
{
    ISP_BOOL bEnable;
} ISP_DIS_ATTR_S;

typedef struct stISP_DIS_INFO_S
{
    ISP_S8 s8Xoffset;         /*RW, Range: [0x00, 0x80]*/
    ISP_S8 s8Yoffset;         /*RW, Range: [0x80, 0xFF]*/   
} ISP_DIS_INFO_S;

typedef struct stISP_SHADING_CALIBRATION_CFG_S 
{
	ISP_U8 u8Ng;
	ISP_U8 u8Nz;		// 1/2/4/8/16/32
	ISP_U16 u16RCenterX;
	ISP_U16 u16RCenterY;
	ISP_U16 u16RRadius0;
	ISP_U16 au16RShadingTbl[SHADING_LUT_NUM];
	
	ISP_U16 u16GrCenterX;
	ISP_U16 u16GrCenterY;
	ISP_U16 u16GrRadius0;
	ISP_U16 au16GrShadingTbl[SHADING_LUT_NUM];
	
	ISP_U16 u16GbCenterX;
	ISP_U16 u16GbCenterY;	
	ISP_U16 u16GbRadius0;
	ISP_U16 au16GbShadingTbl[SHADING_LUT_NUM];
	
	ISP_U16 u16BCenterX;
	ISP_U16 u16BCenterY;
	ISP_U16 u16BRadius0;
	ISP_U16 au16BShadingTbl[SHADING_LUT_NUM];
} ISP_SHADING_CALIBRATION_CFG_S;

typedef struct stISP_SHADING_MANUAL_ATTR_S
{
    ISP_U8 u8Str;
} ISP_SHADING_MANUAL_ATTR_S;

typedef struct stISP_SHADING_AUTO_ATTR_S
{
    ISP_U8 u8GlobalStr;
    ISP_U8 au8Str[ISP_AUTO_STENGTH_NUM];
} ISP_SHADING_AUTO_ATTR_S;

typedef struct stISP_SHADING_ATTR_S
{
    ISP_BOOL bEnable;
    ISP_OP_TYPE_E enOpType;
    ISP_SHADING_MANUAL_ATTR_S stManual;
    ISP_SHADING_AUTO_ATTR_S   stAuto;
} ISP_SHADING_ATTR_S;


typedef struct stISP_DENOISE_ATTR_S
{
    ISP_BOOL bEnable;
    ISP_BOOL bManualEnable;
    ISP_U8 u8ThreshTarget;       /*RW,  Noise reduction effect for high spacial frequencies Range: [0x0, u8ThreshTarget]*/
    ISP_U8 u8ThreshMax;          /*RW,  Noise reduction effect for high spacial frequencies, Range: [0x0, 0xFF] */
    ISP_U8 u8SnrThresh[8];       /*RW,  Noise reduction target value array for  different iso, Range: [0x0, 0xFF],*/
} ISP_DENOISE_ATTR_S;



typedef enum stISP_GAMMA_CURVE_E
{
    ISP_GAMMA_CURVE_1_6 = 0x0,           /* 1.6 Gamma curve */
    ISP_GAMMA_CURVE_1_8 = 0x1,           /* 1.8 Gamma curve */
    ISP_GAMMA_CURVE_2_0 = 0x2,           /* 2.0 Gamma curve */
    ISP_GAMMA_CURVE_2_2 = 0x3,           /* 2.2 Gamma curve */
    ISP_GAMMA_CURVE_DEFAULT = 0x4,       /* default Gamma curve */
    ISP_GAMMA_CURVE_SRGB = 0x5,
    ISP_GAMMA_CURVE_USER_DEFINE = 0x6,   /* user defined Gamma curve, Gamma Table must be correct */
    ISP_GAMMA_CURVE_BUTT
} ISP_GAMMA_CURVE_E;

typedef struct stISP_GAMMA_ATTR_S
{
	ISP_BOOL bEnable;
	ISP_GAMMA_CURVE_E enCurveType;
	ISP_U16 u16Table[GAMMA_NODE_NUMBER];
} ISP_GAMMA_ATTR_S;

typedef struct stISP_ANTI_FALSECOLOR_S
{
    ISP_BOOL bEnable;
    ISP_U8  u8Strength;
} ISP_ANTI_FALSECOLOR_S;

/*users query ISP state information*/
typedef struct stISP_INNER_STATE_INFO_S
{
	ISP_U32 u32ExpTime_short;        /* RO, Range: [0x0, 0xFFFFFFFF] */  
	ISP_U32 u32ExposureTime;         /* RO,  Range: [0x0, 0xFFFF] */                
	ISP_U32 u32AnalogGain;           /* RO,Range: [0x0, 0xFFFF] */                
	ISP_U32 u32DigitalGain;          /* RO,Range: [0x0, 0xFFFF] */  
	ISP_U32 u32IspDGain;          	/* RO,Range: [0x0, 0xFFFF] */  
	ISP_U32 u32Exposure;             /* RO,Range: [0x0, 0xFFFFFFFF] */     
	ISP_U32 u32AllGain; 				/* RO,Range: [0x0, 0xFFFFFFFF] */  
	ISP_U32 u32EnvLum;				/* RO,Range: [0x0, 0xFFFF] */ 
	ISP_U32 au32Rsv[4];
	ISP_U16 u16AE_Hist16Value[16]; /* RO, 256 bins histogram */
	ISP_U8 u8LumError;   
	ISP_U8  u8AveLum;                /* RO, Range: [0x0, 0xFF] */    
	ISP_BOOL bExposureIsMAX;
}ISP_INNER_STATE_INFO_S;





typedef struct stISP_BLACKLVL_AUTO_S
{
    ISP_U16   au16Blc[ISP_AUTO_STENGTH_NUM];           /*RW,  Range: [0, 0xFFFF] */ 
}ISP_BLACKLVL_AUTO_S;

typedef struct stISP_BLACKLVL_MANUAL_S
{
	ISP_U16	u16Blc;
}ISP_BLACKLVL_MANUAL_S;

typedef struct stISP_BLACKLVL_ATTR_S
{
	ISP_OP_TYPE_E enOpType;
	ISP_BLACKLVL_MANUAL_S	stManual;
	ISP_BLACKLVL_AUTO_S 		stAuto;
}ISP_BLACKLVL_ATTR_S;


/*ISP debug information*/
typedef struct stISP_DEBUG_INFO_S
{
    ISP_BOOL bDebugEn;       /*RW, 1:enable debug, 0:disable debug*/
    ISP_U32  u32PhyAddr;     /*RW, phy address of debug info */
    ISP_U32  u32Depth;       /*RW, depth of debug info */
} ISP_DEBUG_INFO_S;

typedef struct stISP_DBG_ATTR_S
{
    ISP_U32  u32Rsv;         /* need to add member */
} ISP_DBG_ATTR_S;

typedef struct stISP_DBG_STATUS_S
{
    ISP_U32  u32FrmNumBgn;
    ISP_U32  u32Rsv;         /* need to add member */
    ISP_U32  u32FrmNumEnd;
} ISP_DBG_STATUS_S;


typedef struct stISP_VD_INFO_S
{
  ISP_U32  u32Reserved;          /*RO, Range: [0x0, 0xFFFFFFFF] */
}ISP_VD_INFO_S;


typedef struct stISP_REG_ATTR_S
{
    ISP_U32 u32IspRegAddr;
    ISP_U32 u32IspRegSize;
    ISP_U32 u32IspExtRegAddr;
    ISP_U32 u32IspExtRegSize;
    ISP_U32 u32AeExtRegAddr;
    ISP_U32 u32AeExtRegSize;
    ISP_U32 u32AwbExtRegAddr;
    ISP_U32 u32AwbExtRegSize;
} ISP_REG_ATTR_S;



typedef struct stISP_EXPOSURE_ATTR_S
{    
    ISP_BOOL         bByPass;
    ISP_OP_TYPE_E   enOpType;
    ISP_ME_ATTR_S   stManual;
    ISP_AE_ATTR_S   stAuto;    
} ISP_EXPOSURE_ATTR_S;


typedef struct stISP_WB_ATTR_S
{
    ISP_BOOL bByPass;
    ISP_OP_TYPE_E   enOpType;
    ISP_MWB_ATTR_S  stManual;
    ISP_AWB_ATTR_S  stAuto;
} ISP_WB_ATTR_S;

typedef enum stISP_STATE_E
{
    ISP_STATE_INIT     = 0, 
    ISP_STATE_SUCCESS  = 1,
    ISP_STATE_TIMEOUT  = 2,
    ISP_STATE_BUTT
} ISP_STATUS_E;


typedef struct stISP_AI_CALIBRATE_S
{
    ISP_BOOL bEnable;     /*iris calibration on/off*/

    ISP_U16 u16StopValue;    /*RW, the initial stop value for AI calibraiton, Range: [0x0,0x3E8]*/
    ISP_U16 u16CloseValue;   /*RW, the drive value to close Iris, Range: [0x0,0x3E8], Recommended value: [700, 900]. A larger value means faster.*/
    ISP_U16 u16CalibrateTime;  /*RW, frame numbers of AI calibraiton lasting time. > 600, [0x0, 0xFFF]*/
    ISP_U8  u8InertiaValue;  /*RW, frame numbers of  AI moment of inertia, Range: [0x0, 0xFF],the recommended value is between[0x3, 0xa]*/

    ISP_U32  u32HoldValue;    /*RO, Range: [0x0, 0x3E8], iris hold value*/
    ISP_STATUS_E enStatus;   /*RO, status of calibraiton*/
} ISP_AI_CALIBRATE_S;

typedef struct stISP_AI_ATTR_S
{
    ISP_U32  u32HoldValue;       /*RW, Range: [0x0, 0x3E8], iris hold value*/
} ISP_AI_ATTR_S;

typedef struct stISP_IRIS_ATTR_S
{
    ISP_BOOL bEnable;        /* iris enable/disable */
    ISP_OP_TYPE_E   enOpType;
    ISP_IRIS_STATUS_E enIrisStatus;  /*RW, status of Iris*/
    ISP_AI_ATTR_S   stAIAttr;
    ISP_MI_ATTR_S   stMIAttr;
} ISP_IRIS_ATTR_S;

typedef struct stISP_SHARPEN0_MANUAL_ATTR_S
{
	ISP_U8 u8Ud;		// 纹理锐化高频强度
	ISP_U8 u8D; 		// 纹理锐化中频强度
	ISP_U8 u8EdgeStr;		// 边界锐化强度
	ISP_U8 u8EdgeThr;		// 边界锐化阈值
	ISP_U8 u8EdgeSlope;		// 边界锐化斜率
	ISP_U8 u8TextureStr;		// 纹理锐化强度
	ISP_U8 u8TextureThr;		// 纹理锐化阈值
	ISP_U8 u8TextureSlope;	// 纹理锐化斜率
	ISP_U8 u8OverShoot;
	ISP_U8 u8UnderShoot;

	ISP_U8 au8Rsv[4];
} ISP_SHARPEN0_MANUAL_ATTR_S;

typedef struct stISP_SHARPEN0_AUTO_ATTR_S
{
	ISP_U8 au8Ud[ISP_AUTO_STENGTH_NUM];		// 纹理锐化高频强度
	ISP_U8 au8D[ISP_AUTO_STENGTH_NUM]; 		// 纹理锐化中频强度
	ISP_U8 au8EdgeStr[ISP_AUTO_STENGTH_NUM];		// 边界锐化强度
	ISP_U8 au8EdgeThr[ISP_AUTO_STENGTH_NUM];		// 边界锐化阈值
	ISP_U8 au8EdgeSlope[ISP_AUTO_STENGTH_NUM];	// 边界锐化斜率
	ISP_U8 au8TextureStr[ISP_AUTO_STENGTH_NUM];		// 纹理锐化强度
	ISP_U8 au8TextureThr[ISP_AUTO_STENGTH_NUM];		// 纹理锐化阈值
	ISP_U8 au8TextureSlope[ISP_AUTO_STENGTH_NUM];	// 纹理锐化斜率
	ISP_U8 au8OverShoot[ISP_AUTO_STENGTH_NUM];
	ISP_U8 au8UnderShoot[ISP_AUTO_STENGTH_NUM];
	ISP_U8 au8Rsv[4][ISP_AUTO_STENGTH_NUM];
} ISP_SHARPEN0_AUTO_ATTR_S;

typedef struct stISP_SHARPEN0_ATTR_S
{
	ISP_BOOL bEnable;
	ISP_OP_TYPE_E enOpType;
	ISP_U8 u8Lut[32];
	ISP_U8 u8GlobalSth;	// [0, 0xFF]
	ISP_SHARPEN0_MANUAL_ATTR_S stManual;
	ISP_SHARPEN0_AUTO_ATTR_S   stAuto;
} ISP_SHARPEN0_ATTR_S;



typedef struct stISP_SHARPEN_MANUAL_ATTR_S
{
	ISP_U8 u8Ud;		// 纹理锐化强度(高频)
	ISP_U8 u8D; 		// 纹理锐化强度(中频)
	ISP_U8 u8ThrUd; 	// 纹理锐化阈值(高频)
	ISP_U8 u8ThrD; 	// 纹理锐化阈值(中频)
	ISP_U8 u8Ud_H;		// 水平锐化强度(高频)
	ISP_U8 u8D_H; 		// 水平锐化强度(中频)
	ISP_U8 u8ThrUd_H; 	// 水平锐化阈值(高频)
	ISP_U8 u8ThrD_H; 	// 水平锐化阈值(中频)
	ISP_U8 u8EdgeStr;	// 边界锐化强度
	ISP_U8 u8EdgeThr;	// 边界锐化阈值
	ISP_U8 u8OverShoot;
	ISP_U8 u8UnderShoot;
	ISP_U8 u8DetailStr;	
	ISP_U8 u8Rsv1;		// 保留
	ISP_U8 u8Rsv2;	// 保留
} ISP_SHARPEN_MANUAL_ATTR_S;

typedef struct stISP_SHARPEN_AUTO_ATTR_S
{
	ISP_U8 au8Ud[ISP_AUTO_STENGTH_NUM];		// 纹理锐化高频强度
	ISP_U8 au8D[ISP_AUTO_STENGTH_NUM]; 		// 纹理锐化中频强度
	ISP_U8 au8ThrUd[ISP_AUTO_STENGTH_NUM]; 	// 纹理锐化阈值(高频)
	ISP_U8 au8ThrD[ISP_AUTO_STENGTH_NUM]; 	// 纹理锐化阈值(中频)

	ISP_U8 au8Ud_H[ISP_AUTO_STENGTH_NUM];		// 纹理锐化高频强度
	ISP_U8 au8D_H[ISP_AUTO_STENGTH_NUM]; 		// 纹理锐化中频强度
	ISP_U8 au8ThrUd_H[ISP_AUTO_STENGTH_NUM]; 	// 纹理锐化阈值(高频)
	ISP_U8 au8ThrD_H[ISP_AUTO_STENGTH_NUM]; 	// 纹理锐化阈值(中频)

	ISP_U8 au8EdgeStr[ISP_AUTO_STENGTH_NUM];	// 边界锐化强度
	ISP_U8 au8EdgeThr[ISP_AUTO_STENGTH_NUM];		// 边界锐化阈值

	ISP_U8 au8OverShoot[ISP_AUTO_STENGTH_NUM];
	ISP_U8 au8UnderShoot[ISP_AUTO_STENGTH_NUM];
	ISP_U8 au8DetailStr[ISP_AUTO_STENGTH_NUM];
	
	ISP_U8 au8Rsv1[ISP_AUTO_STENGTH_NUM];	// 保留
	ISP_U8 au8Rsv2[ISP_AUTO_STENGTH_NUM];	// 保留
} ISP_SHARPEN_AUTO_ATTR_S;

typedef struct stISP_SHARPEN_COM_ATTR_S
{
	ISP_U16 au16TabEdge[32];
	ISP_U16 au16TabText[32];
	ISP_U16 au16TabLum[32];
} ISP_SHARPEN_COM_ATTR_S;

typedef struct stISP_SHARPEN_ATTR_S
{
	ISP_BOOL bEnable;
	ISP_OP_TYPE_E enOpType;
	ISP_U8 u8GlobalSth;	// [0, 0xFF]
	ISP_SHARPEN_COM_ATTR_S stCom;
	ISP_SHARPEN_MANUAL_ATTR_S stManual;
	ISP_SHARPEN_AUTO_ATTR_S   stAuto;
} ISP_SHARPEN_ATTR_S;

typedef struct stISP_2DNR_MANUAL_ATTR_S
{
	ISP_U16 u16Thr;
	ISP_U8 u8KThr;
	ISP_U8 u8KCoef;
	ISP_U8 u8KMin;
	ISP_U8 u8Thr_c;
	ISP_U8 u8KThr_c;
	ISP_U8 u8KCoef_c;
	ISP_U8 u8KMin_c;
} ISP_2DNR_MANUAL_ATTR_S;

typedef struct stISP_2DNR_AUTO_ATTR_S
{
	ISP_U8 u8GlobalSth;
	ISP_U16 au16Thr[ISP_AUTO_STENGTH_NUM];
	ISP_U8 au8KThr[ISP_AUTO_STENGTH_NUM];
	ISP_U8 au8KCoef[ISP_AUTO_STENGTH_NUM];
	ISP_U8 au8KMin[ISP_AUTO_STENGTH_NUM];
	ISP_U8 au8Thr_c[ISP_AUTO_STENGTH_NUM];
	ISP_U8 au8KThr_c[ISP_AUTO_STENGTH_NUM];
	ISP_U8 au8KCoef_c[ISP_AUTO_STENGTH_NUM];
	ISP_U8 au8KMin_c[ISP_AUTO_STENGTH_NUM];
} ISP_2DNR_AUTO_ATTR_S;

typedef struct stISP_2DNR_ATTR_S
{
    ISP_BOOL bEnable;
    ISP_OP_TYPE_E enOpType;
    ISP_2DNR_MANUAL_ATTR_S stManual;
    ISP_2DNR_AUTO_ATTR_S   stAuto;
} ISP_2DNR_ATTR_S;

typedef struct stISP_DEPURPLESTR_MANUAL_ATTR_S
{
	ISP_U16 u16Thresh;
	ISP_U16 u16GThresh;
	ISP_U16 u16YThresh;
	ISP_U8 u8DePurpleStrR;
	ISP_U8 u8DePurpleStrB;
} ISP_DEPURPLESTR_MANUAL_ATTR_S;

typedef struct stISP_DEPURPLESTR_AUTO_ATTR_S
{
	ISP_U8 u8GlobalSth;
	ISP_U16 au16Thresh[ISP_AUTO_STENGTH_NUM];
	ISP_U16 au16GThresh[ISP_AUTO_STENGTH_NUM];
	ISP_U16 au16YThresh[ISP_AUTO_STENGTH_NUM];
	ISP_U8 au8DePurpleStrR[ISP_AUTO_STENGTH_NUM];
	ISP_U8 au8DePurpleStrB[ISP_AUTO_STENGTH_NUM];	
} ISP_DEPURPLESTR_AUTO_ATTR_S;

typedef struct stISP_LOCAL_CAC_ATTR_S
{
	ISP_BOOL bEnable;
	ISP_OP_TYPE_E enOpType;
	ISP_DEPURPLESTR_MANUAL_ATTR_S stManual;
	ISP_DEPURPLESTR_AUTO_ATTR_S   stAuto;
}ISP_LOCAL_CAC_ATTR_S;

typedef struct stISP_YCNR_MANUAL_ATTR_S
{
	ISP_U8 u8Thr;
	ISP_U8 u8Str;
	ISP_U8 u8MixThr;
	ISP_U8 u8Wt1;
	ISP_U8 u8Wt2;
	ISP_U8 u8Wt3;
	ISP_U16 u16K;
} ISP_YCNR_MANUAL_ATTR_S;

typedef struct stISP_YCNR_AUTO_ATTR_S
{
	ISP_U8 au8Thr[ISP_AUTO_STENGTH_NUM];
	ISP_U8 au8Str[ISP_AUTO_STENGTH_NUM];
	ISP_U8 au8MixThr[ISP_AUTO_STENGTH_NUM];
	ISP_U8 au8Wt1[ISP_AUTO_STENGTH_NUM];
	ISP_U8 au8Wt2[ISP_AUTO_STENGTH_NUM];
	ISP_U8 au8Wt3[ISP_AUTO_STENGTH_NUM];
	ISP_U16 au16K[ISP_AUTO_STENGTH_NUM];
} ISP_YCNR_AUTO_ATTR_S;

typedef struct stISP_YCNR_ATTR_S
{
	ISP_BOOL bEnable;
	ISP_OP_TYPE_E enOpType;
	ISP_YCNR_MANUAL_ATTR_S stManual;
	ISP_YCNR_AUTO_ATTR_S   stAuto;
} ISP_YCNR_ATTR_S;

typedef struct stISP_NR_INFO_S
{
	ISP_U8 au8Nr[4];
} ISP_NR_INFO_S;


typedef struct stBPU_3DNR_MANUAL_ATTR_S
{
	ISP_U8 u8MdTh;			// 动静判决阈值
	ISP_U8 u8TfOfst_S;		// 静止区域时域增强		   
	ISP_U8 u8TfStrength;		// 时域强度
	ISP_U8 u8SfStrength;		// 空域强度
	ISP_U8 u8Rsv;			// 保留
} BPU_3DNR_MANUAL_ATTR_S;	

typedef struct stBPU_3DNR_AUTO_ATTR_S
{
	ISP_U8 u8GlobalSth;	 // [0, 0xFF] 
	ISP_U8 au8MdTh[ISP_AUTO_STENGTH_NUM];			// 动静判决阈值
	ISP_U8 au8TfOfst_S[ISP_AUTO_STENGTH_NUM];		// 静止区域时域增强		 
	ISP_U8 au8TfStrength[ISP_AUTO_STENGTH_NUM];		// 时域强度
	ISP_U8 au8SfStrength[ISP_AUTO_STENGTH_NUM];		// 空域强度
	ISP_U8 au8Rsv[ISP_AUTO_STENGTH_NUM]; 			// 保留
} BPU_3DNR_AUTO_ATTR_S;


typedef struct stBPU_3DNR_ATTR_S
{
	ISP_U8 u8AlgChoice;	// 1:Use 3DNrV2
	ISP_U8 u8Enable;		// bit0: 3DNr_Enable   bit4:OSD_Enable(for test)
	ISP_OP_TYPE_E enOpType;
	BPU_3DNR_MANUAL_ATTR_S stManual;
	BPU_3DNR_AUTO_ATTR_S   stAuto;
} BPU_3DNR_ATTR_S;

typedef struct stISP_3DNR_MANUAL_ATTR_S
{ 
	ISP_U8 u8FltThr;
	ISP_U8 u8Df_RatC;
	ISP_U8 u8Df1_RatioY;
	ISP_U8 u8Df1_RatioC;
	ISP_U8 u8MovThr_Max;
	ISP_U8 u8Alpha_Ratio;
	ISP_U8 u8Alpha_Min;
	ISP_U8 u8IdxThr_Max;
	ISP_U8 u8IdxThr_Min;
	ISP_U8 u8Idx_Max;
	ISP_U8 u8FidY;
	ISP_U8 u8FidC;
	ISP_U8 u8FidY_Min;
	ISP_U8 u8FidC_Min;
	ISP_U8 u8YSfThr_Min;
	ISP_U8 u8CSfThr_Min;
	ISP_U8 u8YTfThr_Min;
	ISP_U8 u8CTfThr_Min;
	ISP_U8 u8YAntiRsdlSpd;
	ISP_U8 u8CAntiRsdlSpd;
	ISP_U8 u8YAntiRsdlThr;
	ISP_U8 u8CAntiRsdlThr;	
	ISP_U16 u16YSfThr_K;
	ISP_U16 u16CSfThr_K;
	ISP_U16 u16YTfThr_K;
	ISP_U16 u16CTfThr_K;
	ISP_U16 u16MovThr1;
	ISP_U16 u16MovThr2;
	ISP_U16 u16MovThr3;
} ISP_3DNR_MANUAL_ATTR_S;	

typedef struct stISP_3DNR_AUTO_ATTR_S
{
	ISP_U8 u8GlobalSth;	 // [0, 0xFF]  
	ISP_U8 au8FltThr[ISP_AUTO_STENGTH_NUM];
	ISP_U8 au8Df_RatC[ISP_AUTO_STENGTH_NUM];
	ISP_U8 au8Df1_RatioY[ISP_AUTO_STENGTH_NUM];
	ISP_U8 au8Df1_RatioC[ISP_AUTO_STENGTH_NUM];
	ISP_U8 au8MovThr_Max[ISP_AUTO_STENGTH_NUM];
	ISP_U8 au8Alpha_Ratio[ISP_AUTO_STENGTH_NUM];
	ISP_U8 au8Alpha_Min[ISP_AUTO_STENGTH_NUM];
	ISP_U8 au8IdxThr_Max[ISP_AUTO_STENGTH_NUM];
	ISP_U8 au8IdxThr_Min[ISP_AUTO_STENGTH_NUM];
	ISP_U8 au8Idx_Max[ISP_AUTO_STENGTH_NUM];
	ISP_U8 au8FidY[ISP_AUTO_STENGTH_NUM];
	ISP_U8 au8FidC[ISP_AUTO_STENGTH_NUM];
	ISP_U8 au8FidY_Min[ISP_AUTO_STENGTH_NUM];
	ISP_U8 au8FidC_Min[ISP_AUTO_STENGTH_NUM];
	ISP_U8 au8YSfThr_Min[ISP_AUTO_STENGTH_NUM];
	ISP_U8 au8CSfThr_Min[ISP_AUTO_STENGTH_NUM];
	ISP_U8 au8YTfThr_Min[ISP_AUTO_STENGTH_NUM];
	ISP_U8 au8CTfThr_Min[ISP_AUTO_STENGTH_NUM];
	ISP_U8 au8YAntiRsdlSpd[ISP_AUTO_STENGTH_NUM];
	ISP_U8 au8CAntiRsdlSpd[ISP_AUTO_STENGTH_NUM];
	ISP_U8 au8YAntiRsdlThr[ISP_AUTO_STENGTH_NUM];
	ISP_U8 au8CAntiRsdlThr[ISP_AUTO_STENGTH_NUM];	
	ISP_U16 au16YSfThr_K[ISP_AUTO_STENGTH_NUM];
	ISP_U16 au16CSfThr_K[ISP_AUTO_STENGTH_NUM];
	ISP_U16 au16YTfThr_K[ISP_AUTO_STENGTH_NUM];
	ISP_U16 au16CTfThr_K[ISP_AUTO_STENGTH_NUM];
	ISP_U16 au16MovThr1[ISP_AUTO_STENGTH_NUM];
	ISP_U16 au16MovThr2[ISP_AUTO_STENGTH_NUM];
	ISP_U16 au16MovThr3[ISP_AUTO_STENGTH_NUM];
} ISP_3DNR_AUTO_ATTR_S;


typedef struct stISP_3DNR_ATTR_S
{
	ISP_U8 u8Enable;	// bit0: 3DNr_Enable   bit4:OSD_Enable(for test)
	ISP_OP_TYPE_E enOpType;
	ISP_U8 au8MovLut[17];
	ISP_3DNR_MANUAL_ATTR_S stManual;
	ISP_3DNR_AUTO_ATTR_S stAuto;
} ISP_3DNR_ATTR_S;

typedef struct stISP_MODULE_DEBUG_U
{
	union{
		ISP_U32	u32Debug1;
		struct
		{
			ISP_U32	bitBypassDrv		: 1 ;	/* [0] */
			ISP_U32	bitBypassFvideo 	: 1 ;	/* [1] */
			ISP_U32	bitBypassAScene 	: 1 ;	/* [2] */
			ISP_U32	bitRsv			 : 29;	 /* [3:31] */
		};
	};
	ISP_U32 au32DebugRsv[7];
}ISP_MODULE_DEBUG_U;

typedef union stISP_MODULE_CTRL_U
{
    ISP_U32  u32Key;
    struct
    {
        ISP_U32  bitBypassVideoTest  : 1 ;   /* [0] */
        ISP_U32  bitBypassDPC        : 1 ;   /* [1] */
        ISP_U32  bitBypassBlc  		: 1 ;   /* [2] */
        
        ISP_U32  bitBypassGammaFe 	: 1 ;   /* [3] */
        ISP_U32  bitBypassShading    : 1 ;   /* [4] */
        ISP_U32  bitBypassWBGain     : 1 ;   /* [5] */
        ISP_U32  bitBypassNR2D   	: 1 ;   /* [6] */
        ISP_U32  bitBypassNR3D  		: 1 ;   /* [7] */

       	ISP_U32  bitBypassDRC        : 1 ;   /* [8] */
        ISP_U32  bitBypassColorMatrix: 1 ;   /* [9] */
        ISP_U32  bitBypassGamma      : 1 ;   /* [10] */
        
        ISP_U32  bitDemoire          : 1 ;   /* [11] */
        ISP_U32  bitCC				: 1 ;	/* [12] */
        ISP_U32  bitBypassSharpen    : 1 ;   /* [13] */
        ISP_U32  bitRsv1             : 1 ;   /* [14] */
        ISP_U32  bitRsv2             : 1 ;   /* [15] */
        ISP_U32  bit2Rsv3            : 2 ;   /* [16:17] */
        ISP_U32  bit2Rsv4            : 2 ;   /* [18:19] */
        ISP_U32  bit11Rsv5           : 10;   /* [20:29] */
        ISP_U32  bitDebug            : 1;   	/* [30] */
        ISP_U32  bitBypassAll        : 1 ;   /* [31] */
    };
}ISP_MODULE_CTRL_U;

typedef struct stISP_WB_INFO_S
{
    ISP_U16 u16Rgain;             /*RO, AWB result of R color channel, Range: [0x0, 0xFFF]*/
    ISP_U16 u16Ggain;            /*RO, AWB result of Gr color channel, Range: [0x0, 0xFFF]*/
    ISP_U16 u16Bgain;             /*RO, AWB result of B color channel, Range: [0x0, 0xFFF]*/
    ISP_U16 u16Saturation;        /*RO, Current saturation, Range:[0x0, 0xFF]*/
    ISP_U16 u16ColorTemp;         /*RO, Detect color temperature, maybe out of color cemeprature range*/
    ISP_U16 au16CCM[12];           /*RO, Current color correction matrix*/

	ISP_U8 u8RbOfst;
	ISP_U8 u8GmOfst;
}ISP_WB_INFO_S;

typedef struct stISP_WB_INFO_S_V2
{
	ISP_U16 u16Rgain;
	ISP_U16 u16Ggain;
	ISP_U16 u16Bgain;
}ISP_WB_INFO_S_V2;

typedef enum stISP_CSC_TYPE_E
{
    ISP_CSC_TYPE_601_1 = 0,                /* CSC Type: 601 */
    ISP_CSC_TYPE_601_2,                    /* CSC Type: 601 */	
    ISP_CSC_TYPE_709_1,                    /* CSC Type: 709 */
    ISP_CSC_TYPE_709_2,                    /* CSC Type: 709 */
    ISP_CSC_TYPE_USER,                     /* CSC Type: user define */
    ISP_CSC_TYPE_BUTT,
} ISP_CSC_TYPE_E;

typedef struct stISP_CSC_GLOBAL_ATTR_S
{
	ISP_U8 u8LumaVal;                  /* Luminance: [0 ~ 100] */
	ISP_U8 u8ContrVal;                 /* Contrast: [0 ~ 100] */
	ISP_U8 u8HueVal;                   /* Hue: [0 ~ 100] */
	ISP_U8 u8SatuVal;                  /* Satuature: [0 ~ 100] */
}ISP_CSC_GLOBAL_ATTR_S;

typedef struct stISP_CSC_AUTO_ATTR_S
{
	ISP_U8 au8LumaVal[ISP_AUTO_STENGTH_NUM];                  /* Luminance: [0 ~ 100] */
	ISP_U8 au8ContrVal[ISP_AUTO_STENGTH_NUM];                 /* Contrast: [0 ~ 100] */
	ISP_U8 au8HueVal[ISP_AUTO_STENGTH_NUM];                   /* Hue: [0 ~ 100] */
	ISP_U8 au8SatuVal[ISP_AUTO_STENGTH_NUM];                  /* Satuature: [0 ~ 100] */
}ISP_CSC_AUTO_ATTR_S;

typedef struct stISP_CSC_ATTR_S
{
	ISP_CSC_TYPE_E enCscType;          /* 601 or 709 */
	ISP_BOOL bEnable;
 	ISP_OP_TYPE_E enOpType;	
	ISP_CSC_GLOBAL_ATTR_S stGlobal;
	ISP_CSC_AUTO_ATTR_S	stAuto;
	ISP_S16 as16MatrixRsv[3][4];
} ISP_CSC_ATTR_S;

typedef struct stISP_CHN_ATTR_S
{
	ISP_BOOL bMode;		// 0:Sensor	1: Isp
	ISP_BOOL bMirror;            /*mirror enable*/
	ISP_BOOL bFlip;              /*flip   enable*/

// just updata one time
	ISP_U8 u8i2cChn;
	ISP_U8 u8bitWidth;	//0:8bit 1:10bit 2:12bit 3:14bit 4:16bit
  	ISP_U8 u8VicuChnMask;
	ISP_U8 u8StatByVicuChn;
	// for bpu genHV
	ISP_U32 u32TotalSizeH;
	ISP_U32 u32TotalSizeV;
	ISP_U32 u32ActiveSizeH;
	ISP_U32 u32ActiveSizeV;
	ISP_U32 u32WinStartH;
	ISP_U32 u32WinStartV;
	ISP_U32 u32SensorId;
	ISP_U32 u32BpuCutBegin;	// bit0~bit15: hor_begin   bit16~bit31: ver_begin
	ISP_U32 u32BpuCutActive;	// bit0~bit15: hor_width   bit16~bit31: ver_height
	ISP_U32 u32VpssActive;		// bit0~bit15: hor_width   bit16~bit31: ver_height   (0:same as u32BpuCutActive)
}ISP_CHN_ATTR_S;


typedef struct stISP_COMM_ATTR_S
{
	ISP_SIZE_S stMaxSize;
	ISP_U8 u8BpuMode;		//0: online   1:offline
	ISP_U8 u8VicuChnNum;
	ISP_U8 u8VicuChnMask;	// bit0~bit3: Ch0~Ch3     1:Use    0:No use
	ISP_U8 u8VicuMode;
	ISP_U8 u8ChnNum;			// bpu
	ISP_U8 u8ChnMask;		// bpu
	ISP_U8 u8VpssMode;		// 0: online   1:offline 
	ISP_U8 u8HdrFirstChn;	// vicu chn(vicu chn of hdr 1th frame)
	ISP_U8 u8BufDisable;	// bit0: 3DNr
	ISP_U8 u8Flag;			// bit0: memory saver
	ISP_U8 u8Nr3DMode;		// 0:normal  1:size by drv
	ISP_U8 u8Rsv;
	ISP_U32 au32Rsv[2];
	ISP_U32 u32BufPoolCnt;	// count of pools, (0,VB_MAX_POOLS]    
	struct stIB_CPOOL_S
	{
		ISP_U32 u32BlkSize;
		ISP_U32 u32BlkCnt;
	}astAttrPool[IB_MAX_COMM_POOLS];
}ISP_COMM_ATTR_S;

typedef struct stISP_FRAME_DUMP_S
{
	ISP_U8 u8Mode;	// 0:from vicu  1:from bpu
	ISP_U8 u8VicuChn;
	ISP_U8 u8Rsv;
	ISP_U32 u32Width;
	ISP_U32 u32Height;
	ISP_U32 u32Size;
	ISP_U32 au32PhyAddr[3];
	ISP_U32 au32BufSize[3];
	ISP_U32 au32Rsv[4];
}ISP_FRAME_DUMP_S;

typedef enum enISP_CHROMA_HUE_SEL_E
{
	HUE_SEL_RED		= 0,
	HUE_SEL_YELLOW	= 1,
	HUE_SEL_GREEN	= 2,
	HUE_SEL_CYAN	= 3,
	HUE_SEL_BLUE	= 4,
	HUE_SEL_PURPLE	= 5,
	HUE_SEL_BUTT	
} ISP_CHROMA_HUE_SEL_E;

typedef struct stISP_CHROMA_ATTR_S
{
	ISP_BOOL bEnable;
	ISP_CHROMA_HUE_SEL_E enHue1Sel;
	ISP_CHROMA_HUE_SEL_E enHue2Sel;
	ISP_CHROMA_HUE_SEL_E enHue3Sel;
	ISP_S16 s16Hue1Ofst;
	ISP_S16 s16Hue2Ofst;
	ISP_S16 s16Hue3Ofst;
	ISP_U8 u8SthPu;
	ISP_U8 u8SthR;	
	ISP_U8 u8SthYe;	
	ISP_U8 u8SthG;	
	ISP_U8 u8SthCy;	
	ISP_U8 u8SthB;	
}ISP_CHROMA_ATTR_S;

typedef struct stISP_DEFOG_MANUAL_ATTR_S
{
	ISP_U8 u8Strength;
}ISP_DEFOG_MANUAL_ATTR_S;

typedef struct stISP_DEFOG_AUTO_ATTR_S
{
    ISP_U8 au8Sth[ISP_AUTO_STENGTH_NUM];           /*RW,  Range: [0, 0xFF] */      
}ISP_DEFOG_AUTO_ATTR_S;
   
typedef struct stISP_DEFOG_ATTR_S
{
    ISP_BOOL            bEnable;
    ISP_OP_TYPE_E      enOpType;
    ISP_DEFOG_MANUAL_ATTR_S stManual;
    ISP_DEFOG_AUTO_ATTR_S   stAuto;
	ISP_U8 u8GlobalSth;
   	ISP_BOOL bUserLutEnable;    /*RW,Range:[0,1],0:Auto Lut 1:User Lut*/
    ISP_U8 au8DefogLut[65];       
}ISP_DEFOG_ATTR_S;

typedef struct stISP_LTM_MANUAL_ATTR_S
{
	ISP_U8 u8Rix;
	ISP_U8 u8KjMax;
	ISP_U8 u8KjMin;
	ISP_U8 u8StrD;
	ISP_U8 u8StrB;
}ISP_LTM_MANUAL_ATTR_S;

typedef struct stISP_LTM_AUTO_ATTR_S
{
	ISP_U8 au8Rix[ISP_AUTO_STENGTH_NUM];
	ISP_U8 au8KjMax[ISP_AUTO_STENGTH_NUM];
	ISP_U8 au8KjMin[ISP_AUTO_STENGTH_NUM];
	ISP_U8 au8StrD[ISP_AUTO_STENGTH_NUM];
    ISP_U8 au8StrB[ISP_AUTO_STENGTH_NUM];    
}ISP_LTM_AUTO_ATTR_S;
   
typedef struct stISP_LTM_ATTR_S
{
    ISP_BOOL            bEnable;
    ISP_OP_TYPE_E      enOpType;
    ISP_LTM_MANUAL_ATTR_S stManual;
    ISP_LTM_AUTO_ATTR_S   stAuto;
	ISP_U8 u8GlobalSth;
   	ISP_BOOL bUserLutEnable;    /*RW,Range:[0,1],0:Auto Lut 1:User Lut*/
    ISP_U8 au8UserLutP[16];
	ISP_U8 au8UserLutN[16];
}ISP_LTM_ATTR_S;

typedef struct stISP_DCI_MANUAL_ATTR_S
{
	ISP_U8 u8Strength;
}ISP_DCI_MANUAL_ATTR_S;

typedef struct stISP_DCI_AUTO_ATTR_S
{
    ISP_U8 au8Sth[ISP_AUTO_STENGTH_NUM];           /*RW,  Range: [0, 0xFF] */      
}ISP_DCI_AUTO_ATTR_S;
   
typedef struct stISP_DCI_ATTR_S
{
    ISP_BOOL            bEnable;
    ISP_OP_TYPE_E      enOpType;
    ISP_DCI_MANUAL_ATTR_S stManual;
    ISP_DCI_AUTO_ATTR_S   stAuto;  
}ISP_DCI_ATTR_S;


//注册场中断回调函数
typedef struct stISP_VSYNC_CALBAK_S
{
    ISP_U8            u8Mode;	// 0: 处在Vsync流程最后        1:处在Vsync流程最前
	ISP_S32(*pfn_vsync_deal_0)(ISP_VOID);
	ISP_S32(*pfn_vsync_deal_1)(ISP_VOID);
	ISP_S32(*pfn_vsync_deal_2)(ISP_VOID);
	ISP_S32(*pfn_vsync_deal_3)(ISP_VOID);
}ISP_VSYNC_CALBAK_S;

typedef struct stISP_WB_BAYER_STATISTICS_S 
{ 
	ISP_U16 u16ZoneSizeRow;
	ISP_U16 u16ZoneSizeColumn;
    const ISP_U16 *pau16ZoneR;  
	const ISP_U16 *pau16ZoneG;  
    const ISP_U16 *pau16ZoneB;  
	const ISP_U32 *pau32ChosenP;	// 16*int	(水平低位为左)
	const ISP_U8 *pau8SatP;
} ISP_WB_BAYER_STATISTICS_S; 




typedef struct stISP_SNAP_S
{
	ISP_U8 u8Start;	// 1: Start
	ISP_U8 u8Mode;
	ISP_U16 u16Hight;
	ISP_U16 u16Width;
	ISP_U16 au16StartH[3];	// L R Normal
	ISP_U32 u32BufAddrY;
	ISP_U32 u32BufAddrC;
	ISP_U32 au32Rsv[2];
	ISP_S32 (*pfn_callback)(ISP_S32);
} ISP_SNAP_S;


#endif /* __ISP_COMM_ISP_H__ */
